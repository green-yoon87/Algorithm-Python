# 정리
### 💡**문제 분석 요약**

수빈이가 동생의 위치에 도달하기 까지 최단 시간을 구하라.
→ 즉 n에서 k까지 도달할 수 있는 최단 거리를 구하는 문제이다. 

### 💡**알고리즘 설계**

0 ≤ N ≤ 100,000 이 범위에 있는 각 노드에 대해서 다음과 같은 조건을 만족하면 연결된 노드를 갖는다. ]

- 0< n에 대해서 n-1 노드와 연결된다.
- n<100,000에 대해서 n+1 노드와 연결된다.
- n<50,000에 대해서 2n 노드와 연결된다.

위 조건에 만족하게 graph를 리스트에 세팅한다. 
그 후, bfs를 수행하여 최단거리를 구하면 됩니다.  → queue 자료구조 사용
하지만 depth를 저장하기 위해 (node 값, depth) 형식으로 tuple형을 이용합니다.


### 💡 느낀점 or 기억할정보

최단 시간을 → 최단 거리로 생각하는 문제 
보통 최단 경로를 찾기위해서 DFS보다 BFS를 많이 활용한다.  DFS는 O(노드 개수)²를 방문해야하므로 비효율적이라고 볼 수 있다. 반면에 BFS는 O(노드 개수 + 간선 개수) 만에 구할 수 있다. 

최단 경로 구하기
- 가중치가 없는 그래프(unweighted graph): BFS
- 가중치가 0이거나 1인 그래프: BFS
- 가중치가 여러 개인 그래프:  다익스트라 알고리즘

> 정리
> 
> - 경로의 특징을 저장해둬야 하는 문제 예를 들면 각 정점에 숫자가 적혀있고 a부터 b까지 가는 경로를 구하는데 경로에 같은 숫자가 있으면 안 된다는 문제 등, 
> 각각의 **경로마다 특징을 저장**해둬야 할 때는 DFS를 사용한다. (BFS는 경로의 특징을 가지지 못함)
> - 최단거리 구해야 하는 문제미로 찾기 등 최단거리를 구해야 할 경우, BFS가 유리하다. 왜냐하면 깊이 우선 탐색으로 경로를 검색할 경우 처음으로 발견되는 해답이 최단거리가 아닐 수 있지만,너비 우선 탐색으로 **현재 노드에서 가까운 곳부터 찾기** 때문에 경로를 탐색 시 먼저 찾아지는 해답이 곧 최단거리기 때문.

> 이밖에도
> 
> - 검색 대상 그래프가 정말 크다면 DFS를 고려
> - 검색대상의 규모가 크지 않고, 검색 시작 지점으로부터 원하는 대상이 별로 멀지 않다면 BFS를 고려하는 것이 좋다.
